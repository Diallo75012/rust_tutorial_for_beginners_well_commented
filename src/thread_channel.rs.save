// let's do the initial imports
use std::thread;
use std::time::Duration;


// Example 1:
// we are going to create our first `pub` fn
pub fn multithreading_mangakissa_parallel() {
  // `spawn()` here is a closure therefore...
  let _spawned_thread = thread::spawn( || {
    for num in 0..50 {
      println!("I am having {} free drinks in the manga kissa.", num);
      thread::sleep(Duration::from_millis(1));
    }
  });

  let _spawned_thread_2 = thread::spawn( || {
    for num in 0..50 {
      println!("I am reading {} free books in the manga kissa.", num);
      thread::sleep(Duration::from_millis(1));
    }
  });
  
  for num in 0..50 {
    println!("I am hidding in cabin {} of the mangakissa.", num);
    thread::sleep(Duration::from_millis(2));
  }

}
*/

pub fn multithreading_managakissa_waiting_thread_to_finish_first() {
  let spawned_thread = thread::spawn( || {
    for num in 0..10 {
      println!(
        "I am having {} free drinks in the manga kissa.",
        num
      );
    }
  });

  // here we use `.join()` like in Python to wait for the thread to finish before executing the rest of the code
  // as we are not using `.unwrap()` the compiler proposed // to use `let _=` instead but we can handle with `match`
  let _ = spawned_thread.join();


 
 
 
s
 
 
 
 
 
 
,
 
 
}






